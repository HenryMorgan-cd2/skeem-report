## Fetching Data

Fetch requests allow developers to load specific information from the database.

Fetch requests are written in a declarative manner. This means you simply declare that you want all the published articles with their comments and the system will calculate the necessary steps to achieve this goal. This is opposed to traditional SQL where you have to state exactly _how_ to retrieve the data e.g join these two tables together using this column.

Requests are made up of a target model which acts as the root for the query, and a set of optional configuration to specify exactly what data is needed. This includes the attributes to retrieve for each record, how to order the records, and a filter determining which records to receive.

A fetch response will always be an array of records, where each record will contain its own id as well as any additional attributes you requested. In some cases you may also retrieve the total record count see the section [Pagination](#pagination).

```{.json caption="A request for fetching published articles."}
{
  // starting from the articles
  "articles": {
    // load the ones which are "published"
    "filter": { "scope": "published" },
    // get their names and bodies
    "attributes": ["name", "body"],
    // sort by their createdAt date newest first
    "sort": { "attr": "createdAt", "dir": "desc" }
  }
}
```

### Attributes

Attributes specify what data you want to receive for each record. In the request, they take the form of an array where each element specifies a separate attribute. If no attributes are specified then each record will just contain their ids.

When requesting an association attribute you can specify another complete fetch query nested within. This includes its own attributes, filter, sorting, etc. Skeem will then process this configuration in the context of the associations model whilst also limiting the results to only associated records.

The attributes of the associated attribute can further contain more associations. By nesting these queries you can obtain a complete tree of data.

```{.json caption='Retrieving the comments attribute and specifying additional attributes and a filter'}
...
"attributes": [
  {
    "name": "comments",
    "attributes": ["author"],
    "filter": { "scope": "topRated" }
  }
]
...
```

In certain circumstances you may wish to rename the attribute during the request. This could be, for instance, if you need to request the same association attribute with two different filters. This can be done by specifying an `as` property along side the attribute name.

```{.json caption='This query will retrieve the name attribute but will name it "title" in the response."'}
...
"attributes": [{ "name": "name", as: "title" }]
...
```

### Filter

Filters restrict what records are retrieved, by default a query will return all the records for a given model. They are identical to scopes and have access to all of the same operations.

It is recommended though that filters should just use the `scope` operation where possible. This is desirable as it allows for sharing logic between parts of the app - it is unlikely that the notion of published articles will change throughout the app. Using scopes also allow for changing the definition of filters across the app without having to update each use of the filter.

```{.json caption='A filter using the "published" scope.'}
{
  "filter": {
    "scope": "published"
  }
}
```

There are times, however, where using a scope would be non-desirable. If, for instance, you were expecting to retrieve a single record, e.g you want to find the blog article with a particular title. Creating a scope for each one of these cases would cause not only result in the creation of lots of scopes, but also creates a separation between what data is being received and what data is needed - one of the main problems Skeem is addressing.

### Sort

Sorting data is an extremely common and essential capability of data retrieval: most recent tweets, newest article, product name. When sorting data you specify what you want to sort `by` and the `direction` you want to sort: either *asc*ending or *desc*ending.

```{.json caption='This query will return all articles ordered by the articles "name" attribute.'}
{
  articles: {
    sort: {
      by: "name",
      direction: "asc"
    }
  }
}
```

You can also specify an array of sorting criteria. Doing this will sort the data initially by the first item, then resolve conflicts with the next item in the list.

\label{pagination}

### Pagination

The pagingation options allows for the splitting of a request into multiple discrete pages. This is a common practise throughout the web as having the user download thousands of records would lead to a slow and unpleasent user experience. The functionality of pagination is akin to that of the `LIMIT` and `OFFSET` abilities of SQL.
The returned data will be equivalent to a standard array of records.

```{caption="This query will return the second page of articles where each page holds 30 records." .javascript}
{
  articles: {
    pagination: {
      page: 2,
      perPage: 30,
    }
  }
}
```

#### Record count

When paginating the response will also contain a count of the number of the total number of records records you would have received without pagination. This is useful for showing users controls for navigating between pages.

$$ totalPages = ceiling( totalRecords / perPage ) $$

Retrieving the record count can be disabled by passing the option of `withCount: false`.

## Mutating Data
