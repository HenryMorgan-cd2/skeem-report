# Problem Definition

This chapter will provide an overview of the problems associated with building web applications. It will offer a high level overview of existing practices, how they currently function, why they exist and tje problems that exist which require solving.

## API Design

APIs tend to not be broken up into one end-point per page, but rather one end-point per resource. In other words, an API would tend to have an end-point for retrieving blogs and another for retrieving comments as opposed to a single one for handling the "blogs page". This is done to facilitate the notion of not requesting data that is not needed. If for some reason, the javascript wants to render the article without its comments then it shouldn't be forced to receive them anyway. Good API design is a difficult thing and there are a number of issues that present themselves when creating one.

### Code Repetition

Consistent and discoverable APIs tend to lead to very repetitive code. If, for example, you need an end point to fetch a list of blogs and you also need one to fetch all the products. What is really different about these routes? The table name in the SQL query and the columns it returns. This duplication of code leads to highly duplicated code, something which is almost always undesirable [@duplicate_code](http://www.informit.com/articles/article.aspx?p=457502&seqNum=5).

### Data Duplication

There is also a trade off to be made between receiving unnecessary data and have many very similar endpoints. For instance, imagine having an end point requesting a list of blog posts. On the site you wist to display the title of each blog along with a some preview text and the authors name. On the same website you also have a page for viewing an individual blog. This page contains a blogs title, body, its authors name, and a posted date. Here, both pages request very similar data, only differing in one pages need for the posted date. The options here are to either have two very similar end points which return near identical data, or forcing the end user to download the posted at information when they may never actually need to render it. The former leads to having to maintain two distinct APIs where as the latter uses unnecessary data. Neither option is desirable.

## Storage vs Display

Databases should store normalizes data which, simply speaking, means storing data in flat tables i.e one for articles, one for authors, one for comments and then you storing relational information between different records. Storing data in the fashion is desirable as it greatly removes data duplication which makes updating records easier and removes the risk of desyncing data by only updating it in a single location.

The issue with this, however, is that data is not displayed like this to the end user. The end user is not presented with a page containing an article and is required to navigate to a separate page displaying the authors name then have to navigate to a third place to read a list of comments. Rather the end user will be presented with a single page containing all the data amalgamated in an easily digestible and pleasant format. The data the user sees can be envisioned as a tree of data: the root being the article itself and then containing a connected nodes for each comment each having further nodes containing their authors.

The need to request a tree of data from a database is an extremely common and useful thing, however, despite being conceptually simple it can get incredibly complex even when having to traverse only a few levels deep.

![](./images/tree-diagram.png)
![](./images/tree-with-joins.png)

## API and View separation

The SPA architecture has the harsh divide between the view code and the API code. I.e code which is responsible for making the requests is very separate from that rendering the views, up to the point where they could be written in different languages. This separation presents multiple issues.

### Tight Coupling

<!--
- Tight coupling of DB <=> API and API <=> Views.
 -->

APIs tend to be closely related to the underlying database storing the data. If you have a properties table, then you will want a properties API to access the data. If you were to change the name of a column within the database then you would have to remember to update the API to match and this problem grows if you have tables which span multiple APIs.

There is a similar relationship between the client and the API. When an attribute is changed on the API then everywhere using that attribute is required to update simultaneously else risk displaying incorrect responses or worse, completely crash if vital data is changed.

Tight coupling and disparate implementations leads allows for the opportunity for a de-sync which will inevitably lead to bugs.

### Cognitive complexity

Having the data defined in one location and used in another can make if very difficult to comprehend what is going on. It can also make it very easy to make mistakes regarding the data structures the API returns compared to how it is used. Having to understand the data flow across so many levels, through so many systems can make it very difficult to fully understand where something is coming from and why certain effects are happening.

This additional cognitive load can easily make simple tasks look complicated and paves way to slow development. It also creates a high barrier to entry, making it very hard to teach new people how the system works.

### Bespoke Knowledge

Similar to the problem of cognitive complexity, having data flows which span many systems leads to the need to understand a lot of processes spanning lots of domains. This is especially true if the API is written in a different language to the front end.

For instance, given a PHP server, when adding a new feature it is quite likely you would have to in some way know: SQL to query the data, PHP to perform the database query and format the response, javascript to perform the api request, and html to render the view.

This need to be knowledgeable about so many domains raises the base level of skill needed to perform many tasks which makes it difficult to introduce new people to the system.

## Boilerplate

Another issue with the existing method is there is a lot of boiler plate to be setup before a project can be started. You have to set up a system to manage database connections, handle database migrations, seeding data, api routing, authentication, etc. Although some of these systems may already be abstracted and so involve minimal amounts of setup and configuration it is still files which are present and visible within a project. This bloat has a few major drawbacks.

Firstly, it can be overwhelming for new entrants to the system to be faced with so many different entwined parts. Secondly, since it is code openly available to be changed within the repository there is the chance that someone unintentionally changes something and inadvertently breaks the system.

Having a large amount of boiler plate also makes it more challenging when starting a new project. This is because when starting something new you either duplicate an existing application and start stripping out unwanted features. Alternatively, you start from scratch and keep adding all the parts until everything is setup. The first can lead to unnecessary code being left in and the latter can take time to implement. Both can requires some knowledge of how the systems work and both delay the start of the task actually wanting to be achieved.

## Authentication

Authentication is the process of ensuring that a request is being made by the person for whom it claims to be. It is not an issue specific to APIs and in fact is present on any application with a user system.

> :note todo

## File Management

Many websites will at some point have the ability for users to upload files in some form, be it a profile picture, a product listing or a blog hero. File uploads usally tend to have a very different request format then that of a normal request - the request usally takes the form of what is called a multipart request. A multipart request combines multiple types of data into a single requests, for instance an image and a JSON request [https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html].

Trying to perist the APIs consitency through end points which except this style of request can be difficult. There are two real solutions: forgo consistency and discoverablity and accept a bespoke end point. or allow all requests to be multipart requests even when it is purely json being sent. Multipart requests have the downside of being relateivly user hostile to view and browsers tend to be worse at providing developer tools for viewing them as they are expected to contain binary data, this makes the latter solution undesirable.
