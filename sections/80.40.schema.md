## The Schema

The schema is a single JSON object with three main parts: db, models, and providers.

```{.json caption="The empty schema."}
{
  "db": {
    "functions": [],
    "tables": []
  },
  "models": [],
  "providers": []
}
```

### Db

The db section stores the current structure of the database.

#### Tables

The primary use of the db array is storing the definition of all tables with names, columns, indexes and constraints.

By default, every table has an id field which acts as the primary key. This field is of type UUID and has its value initialised automatically to a random value generated by a cryptographically secure random generator. Having a dedicated, synthetic primary key was chosen, as opposed to natural keys, as it helps enforce consistency throughout the system, with the additional benefit of removing choice from the developer and thus removing the need for some additional knowledge about databases. It also prevents having to deal with database-wide updated when the natural-key changes.

```{.json caption="The schema definition of a table"}
{
  "name": string
  "columns": IColumn[]
  "indexes": IIndex[]
  "triggers": ITrigger[]
}
```

#### Functions

Also contained is a list of all custom functions, each having a name, language, and code body. Custom functions allow for complex functionality to be abstracted up into the database itself. Skeem uses a custom function in order to format its results when paginated. This function, however, is not stored within the schema as it is not application specific.

The functions are an experimental addition, and as of the time of writing, no publically accessible features exist which utilise these functions.

### Models

Models define precisely what data there is and how it can be queried. Each model has a globally unique name used to identify.

Models also store a tableName field. This name references a particular table stored in the schemas `db` object. The tableName is independent of the name of the model, though when created they use the same value, as it allows for the renaming of the model without having to alter the database and any references to the given table.

Attributes and permissions are complex in and of themselves, and therefore will be discussed sections \ref{attributes_sec} and \ref{permissions_sec} respectively.

Scopes allow for the definition of subsets of records, such as published articles. Each scope is an object containing a name, to identify the scope; a query, taking the form of an operator tree, which defines how to realise the subset; and a set of parameter definitions which defines the arguments the scope can accept. Section \ref{compiling_operators} discusses operator trees at length.

When the private field is true, Skeem will prevent querying the model directly. Instead, the only way to access the model is through an association. This ability is required as Skeem does not support polymorphic associations (an association that leads to one of the multiple different models). Therefore, it is not possible,  in certain circumstances, to create accurate permission scopes. For instance, given a model which stores addresses, and the desire to use this same model for many other models (e.g. for users and for properties), then the necessary permissions would likely be: users can only access their address or any used for properties, i.e. not addresses belonging to other users. Since creating an association from addresses to the other models is not possible, there is no way to determine if the address is for properties or users. Setting the model to private avoids the issue as access to a joined record would be required before accessing an address.

The `live` and `callbacks` keys store information about features which are currently a work in progress.

Callbacks allow for taking actions after certain events, such as send an email when creating a new record or perform a mutation before deleting a record. These callbacks will significantly increase Skeems flexibility, but as of yet, they are in the testing stage before being released.

Live records utilise web sockets to inform the client of when records change. From the client, developers can subscribe to a given fetch query and then have a callback triggered when the results of that query update. These updates allow for views always to display the most accurate information and also enables applications such as real-time messengers. This feature is currently hidden behind a flag, as further testing is required and more thought put into the client API before it could be released publicly. A proof of concept exists with extremely positive results.

```{.json caption="The schema definition of a model."}
{
  "name": string
  "tableName": string
  "attributes": IAttribute[]
  "scopes": IScope[]
  "permissions"?: { [roleName: string]: IPermission }
  "private"?: boolean
  "live"?: { enabled: boolean }
  "callbacks"?: IModelCallback[]
}
```

### providers

Providers store a set of configurations defining how users can be authenticated. Providers is stored as an array with each element configuring a single authentication strategy. Section \ref{permissions_sec} discusses the purpose and structure of session providers in detail.
