## The Schema

The schema is a single JSON object with three main parts: db, models, and providers.

```{.json caption="The empty schema."}
{
  "db": {
    "functions": [],
    "tables": []
  },
  "models": [],
  "providers": []
}
```

### Db

The db section stores the current structure of the database.

#### Tables

The predominant use of the db array is storing the definition of all tables with names, columns, indexes and constraints.

By default every table has an id field which acts as the primary key. This field is of type uuid and has its value initialized automatically to a random value generated by a cryptographically secure random generator. Having a dedicated, synthetic primary keys was chosen, as opposed to natural keys, as it helps enforce a consistency throughout the system, this has the added benefit of removing some choice from the developer and thus removing the need for some additional knowledge about databases. It also prevents having to deal with database wide updated when a composite key changes.

```{.json caption="The schema definition of a table"}
{
  "name": string
  "columns": IColumn[]
  "indexes": IIndex[]
  "triggers": ITrigger[]
}
```

#### Functions

Also contained is a list of all custom functions, each having a name, language, and code body. Custom functions allow for complex functionality to be abstracted into the database itself. Skeem uses a custom function in order to properly format its results when paginated this function however is not stored within the schema as it is not application specific.

The functions are an experimental addition and as of the time of writing, no public features exist which utilize these functions.

### Models

Models define exactly what data their is and how it can be queried. Each model has a globally unique name used to identify it. They are comprised of many mostly independent parts.

Models also store a tableName field, this references a particular table stored in the schemas `db` object. The tableName is independent of the name of the model, though when created they use the same value, as it allows the model to be renamed without having to alter the database and any references to the given table.

Attributes and permissions are complex in and of themselves, and therefore will be discussed sections \ref{attributes_sec} and \ref{permissions_sec} respectively.

Scopes allow for the definition of subsets of records, such as published articles. Each scope is an object containing a name, to identify the scope; a query, which defines how to realise the subset; and a set of parameter definitions which defines the arguments the scope can accept. The query is an operator tree, which are discussed at length in section \ref{compiling_operators}.

When the private field is true, Skeem will prevent querying the model directly. Instead the only way to access the model is through an association. This one done as skeem does not support polymorphic associations (an association that leads to one of multiple different models). Therefore, it is not possible to create accurate permissions in certain circumstances. For instance, if you had a model for storing addresses, and you wanted to use this same model for many other models (e.g for users and for properties), then you would want the permissions to be: users can only access their own address or those used for properties. Since you cannot create an association from addresses to the other models their is no way to determine if the address is used for properties, therefore by setting the model to private you avoid the issue as you would need access to a joined record to access an address.

The `live` and `callbacks` keys store information pertaining to features which are currently a work in progress.

Callbacks allow for actions to be taken after certain events, such as send an email when a new record is created or perform a mutation before mutating a record. These callbacks will greatly increase Skeems flexibility but as of yet they are in the testing stage before being released.

Live records utilize web sockets to inform the client of when records change. From the client, developers are able to subscribe to a given fetch query and then have a callback triggered when the results of that query update. This allows for views to always display the most accurate information and also enables applications such as real-time messengers. This feature is currently hidden behind a flag, as further testing needs to be done and more thought put into the client API before it could be released publicly. A proof of concept has been created and results have been extremely positive.

```{.json caption="The schema definition of a model."}
{
  "name": string
  "tableName": string
  "attributes": IAttribute[]
  "scopes": IScope[]
  "permissions"?: { [roleName: string]: IPermission }
  "private"?: boolean
  "live"?: { enabled: boolean }
  "callbacks"?: IModelCallback[]
}
```

### providers

> :comment TODO: the providers stores a list of available
