## The Schema

The schema is the central part of all of Skeems functionality. It is used to derive the database structure, covering everything from the tables to the columns, indexes and triggers. The schema is also used to validate the queries being sent and transform them into SQL which can the be sent to the database.

## Models

Models define the actual data to be stored. Models also define a set of permissions determining who can access given records.

### attributes

A models attributes are similar to a tables columns in a relational database in that they define a specific data type to store. Each attribute has a unique name in the context of the model and stores a single data type.

There are many built in attribute types designed to cover all common use cases of data storage. The built in attributes include:

\begin{multicols}{4}
\begin{itemize}
\item string
\item number
\item boolean
\item date
\item associations
\item passwords
\item files
\end{itemize}
\end{multicols}

Each attribute type has an set of configuration options to define how it should function, including how it is retrieved and how it should be stored. For instance booleans can set their default value, numbers can be declared to be an integer, or strings may enforce uniqueness.

Many of the attributes have some configuration related to validation. For example, strings allow you to declare that they must be present (not an empty string) before being able to save a record, or numbers can specifiy a minimum and a maximum value.

One key feature of skeem is its ability to request trees of data, this is done via the association attribute. Association attributes are configured with a model they are leading to, this determines where to go when following the association. They also define a numerically, either a "has one" or a "has many".

### Scopes

Scopes define subsets of data: published articles, popular products, banned users. They are built from many operator functions which will compiled down into a single value.

There are many built in operators which provide range from very simple processes such as `eq` for equivalence, or `lt` for less than up to complex ones such as `path` which will traverse through many associations such as `invoice > product > category > name`. If the result after processing the operators is "truthy" for a given record then that records will be part of the subset. By combining different operations you can form a large array of filters covering many use cases.

```{.json caption="A filter using the 'eq', 'attr', and 'value' operators to filter only records whose name equals 'some text'"}
{
  "filter": {
    "eq": [
      { "attr": "name" },
      { "value": "some text" }
    ]
  }
}
```

The following is a list of all operators built into skeem.
\begin{multicols}{3}
\begin{itemize}
\item eq
\item lt
\item lte
\item gt
\item gte
\item in
\item path
\item empty
\item anyIn
\item not
\item and
\item or
\item attr
\item value
\item param
\item session
\item id
\item now
\item like
\item ids
\item query
\item scope
\item associationEquals

\end{itemize}
\end{multicols}

### Migrations

Mutations of the schema are done through migrations. Migrations define a specific change that wants to be made such as adding a model or renaming an attribute.

Migrations present a way to easily make changes to the schema in a way which is repeatable, this is essential as when building an application there are usually separate environments for development and production. Migrations, therefore, allow for a record of changes need to be made so after creating a feature in the development environment they can be run in production to mutate that schema.

When a migration is executed it stores some additional data about what was changed. This allows migrations to be reversed. The migrations to add a model, upon reversal, will delete the model thus restoring the schema to its previous state.
