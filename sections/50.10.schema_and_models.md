## The Schema

The schema is the central part of all of Skeems functionality. It is used to derive the database structure, covering everything from the tables to the columns, indexes and triggers. The schema is also used to validate the queries being sent and transform them into SQL which can the be sent to the database.

## Models

Models define the actual data to be stored. Models also define a set of permissions determining who can access given records.

### attributes

A models attributes are similar to a tables columns in a relational database in that they define a specific data type to store. Each attribute has a unique name in the context of the model and stores a single data type. There are many built in attribute types designed to cover all common use cases of data storage.

One key feature of skeem is its ability to request trees of data, this is done via the association attribute. Association attributes are configured with a model they are leading to, this determines where to go when following the association. They also define a numerically, either a "has one" or a "has many".

### Scopes

Scopes define subsets of data: published articles, popular products, banned users. They are built from many operator functions which will compiled down into a single value.

There are many built in operators which provide range from very simple processes such as `eq` for equivalence, or `lt` for less than up to complex ones such as `path` which will traverse through many associations such as `invoice > product > category > name`. If the result after processing the operators is "truthy" for a given record then that records will be part of the subset. By combining different operations you can form a large array of filters covering many use cases.

```{.json caption="A filter using the 'eq', 'attr', and 'value' operators to filter only records whose name equals 'some text'"}
{
  "filter": {
    "eq": [
      { "attr": "name" },
      { "value": "some text" }
    ]
  }
}
```

The following is a list of all operators built into skeem.
\begin{multicols}{3}
\begin{itemize}
\item eq
\item lt
\item lte
\item gt
\item gte
\item in
\item path
\item empty
\item anyIn
\item not
\item and
\item or
\item attr
\item value
\item param
\item session
\item id
\item now
\item like
\item ids
\item query
\item scope
\item associationEquals

\end{itemize}
\end{multicols}

### Migrations

Due to the criticalness of the schema developers do not modify it directly. The schema can grow to be a very large data object with a very strict format.

Allowing for direct manipulations of the schema could easily lead to unwanted outcomes including complete system failiure if the strucutre were to be changed from the expected. Another issue is that if two developers were working on the same skeem-powered project then it may be hard for them to resolve the difference if they both change the schema.

To solve mutate the schema safely developers create migrations defining the exact change they wish to make (adding a model, renaming an attribute, etc). Each migration is stored in a separate file. This means that........

Developers can then execute these migrations in order to manipulate the schema and thus the database in a repeatable and reversible manner.
