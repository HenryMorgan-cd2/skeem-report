# Requirements

This chapter will outline what a system would need to do in order to effectively solve all of the discussed issues.

## High level requirements

These are requirements needed which directly solve the issue.

The approach demonstrated GraphQL+Relay and my mongoDB of allowing queries to be formed and sent directly from the client-side solves many of the outlined issues in an extremely effective manner. It helps to remove one side of thr tight coupling seen with a separated view and api approach. It also completely eliminates the issues associated with API design. It does come with the requirement of needing a query interface which can be properly sanitized from malicious attack.

The ability to query from the client naturally leads to the system requiring a sense of who is making the request, therefore having a built in permission system and authentication system is a logic step.

Many websites have sub-systems which have not been discussed or at least some need to perform custom actions which can only securely be executed on a server. Therefore, having the system capable of being used from both a client and a server is a necessity as to not create a scenario what having used the system prevents needed functionality.

The handling of files is a very pre-defined task, that is to say there are an obvious, and very limited, set requirements - files must be able to be uploaded and downloaded. Building the ability to handle files into the system would help to reduce the amount of boiler plate surrounding the system and also would allow for a consistent API to be created.

Like with file management, the uses of a database in the context of web applications is fairly limited, and so unlike GraphQL I believe the system could be very opinionated as to the structure and contents of the database. This has the added benefit of reducing coupling between the API and DB structures and removes the need to define the structure in two places. Additionally this would help to limit some specific knowledge needed to manage a database.

A system containing this level of functionality and so opinionated as to be able to remove boilerplate would need documentation to educate people as to what the system does and how exactly each part works.

## Specification Gathering

In order to create a solution which will alleviate these issues I had to ensure that the system achieved everything needed to replace existing systems rather then just add a further system which must be configured, maintained and learnt.

accessed an in-production data base and pulled a list of all interactions with the database

- used by 4'000 unique visitors a day
- 4% are new visitors
- 20'000 registered users

I went through all interactions with the database and records how it was being used:

- attributes
  - has many through
  - has many through where condition
  - has many with condition
  - has many dependent nullify
- Validations
  - presence
  - uniqueness
  - inclusion
  - number greater than
  - uniqueness in scope of attr: value
  - validate uniqueness in scope with condition unless attribute: value
  - Validates on: :create
  - association.attribute must = value
  - validates [if/unless] attribute: value
- Callbacks
  - before_validation
    - default attribute to another attribute if not present
    - default attributes only on create
    - default attributes to parameterized other attribute
    - default attribute to association attribute
  - before_create
    - self.slug = name.parameterize
  - after_create
    - update association
    - send emails
    - update self
- Scopes
  - where(attr: value)
  - where.not(attr: value)
  - order(attr: :desc)
  - where association count >= 1
  - where association count === 0
  - where association attribute
  - where in associations scope e.g where(tag_id: Tag.published)
  - composing scopes ( adding limits)
- Permissions
  - through user association
  - through user association | where(attr: value)

Using this information I obtained the minimum viable feature set needed

## Technical requirements

combining these two sets of requirements produces the following set: ....

Must be able to cope with any future requirements and not pigeonhole functionality.

- Create Models
  - store basic types strings, number
  - store associations between two models
  - store files
- Fetching
  - attributes
    - Request primitive attributes such as strings, numbers
    - request associations
  - provide a filter to a query
    - request a record given the records id
    - request a record based on its attributes i.e requesting published records
  - sort queries
    - by attributes
    - by associations attributes
  - pagination queries
- Mutations
  - create records
  - Update records
  - delete records
  - add/remove association records
  - upload files
  - validate data
- Sessions
  - Authenticate users
  - Specify users permission to access data
- Consistency
  - Use web sockets to be alerted to updates
- Permissions

  - Specify access (read + write + remove) of users on:
    - records
    - attributes

- Provide a way to change production databases safely

- GUI
  - Provide a way to create a database
  - Provide a way to create a model
  - add/update/remove attributes from models
  - seed data
  - view records for a model
