## Fetches {#fetches_sec}

All fetch requests perform a single database request independent of how simple or complex of a query is made. The query also returns data in the correct format and requires no post-processing.

Fetches start by performing some basic type assertions about the incoming request. The request is checked to be an object with a single key. This key is ensured to be a valid model name and the value is an object with some subset of the keys: filter, attributes, sort, pagination. If there are any additional keys the request is deemed to be erroneous. If any of these checks fail then a malformed request error is thrown containing additional information explaining the exact issue.

```{.javascript caption="A malformed request and the corrosponding response"}
REQUEST:
{ articles: {},  comments: {} }

RESPONSE:
{ error: { type: 'malformedRequest', data: 'multiple models passed to fetch query, only one allowed.' }
```

Parsing a fetch request starts with the instantiation of a class named `SqlQuery`. This instance holds all the information about the final query to be executed, such as the current columns being selected, the where conditions, the limit etc. Each step in processing a the request gets given this object and simply has to adds the relevant data.

The `SqlQuery` object has an execute function which receives a connection to the database and returns the result of the query.

### Permissions

The first step in processing the query is to find and apply and relevant permissions for the model. The process of how these permissions are discovered and processed is covered in section \ref{permissions_sec}.

### Filter

Next the filter of the query is processed, which is now comprised of the filters passed directly in the request and also the result of the permission step.

The filters are simply an instance of an operation tree, details of how this is compiled can be seen in section \ref{compiling_operators}.

The result of compiling the filters is an SQL string and a predicted type. If the type is deemed to be `never` i.e there would be no results, then the request is aborted and the empty result set is returned. This optimization allows for many requests to be processed without the need to touch the database at all.

If the type is anything else, however, then the SQL string is simply appended to the `where` attribute of the query object.

### Attributes

After compiling a filter the attributes are processed. Attributes define precisely what data is returned. If no attributes are specified within the fetch query then only the id is returned.

Attributes take the form of an array (this is asserted by a type check) this array contains either strings or objects. If an element is a string then it is inflated becoming `{ name: "the string value" }`. This creates an array of object each with a name property. The name property on the attributes relates to directly to an attribute on the model. This is looked up and an error is thrown if the attribute is not found. The attributes `get` method is then called allowing attributes to fully control what it means to retrieve the data.

> :comment talk about aliases

```{.javascript caption="The algorithm used to parse the attributes part of a fetch query"}
for each attribute query in the array
  if the attribute query is a string then
    inflate it to become { name: "attribute query string value" }
  end

  from the selected model, find the attribute with the matching name.

  if the attribute exists then
    call the attributes get method
  else
    throw an unknown attribute type error
  end if
end for
```

Details about how each different attribute type works to produces its SQL is described in section \ref{attributes_sec}.

### Sorting

Sorting controls the order in which the result records appear. Firstly, the sort query is checked to be an array, if it is not then a new array is created and the sort query is set as its only element. Each element of this array is now type checked, ensuring each is an object containing a `direction` (either **asc**ending or **desc**ending) and a `by` value (can be anything and will be checked momentarily). If either of these are missing or the direction is an invalid value, then a `malformedRequest` error is thrown.

If the `by` value is a string then, the attribute is loaded from the model (throwing an error is missing). Then the attributes `sort` method is called which produces the adds the necessary SQL to the query object. If the attribute type does not define a `sort` method, an error is thrown stating that it is an unsortable attribute, this is the case for file and association attributes.

The `by` value may be an object with a key of association. In this case the `by` value contains a name of an attribute with the type of association as well as an `attribute` property. In this instance, the query will be sorted by the given attribute value for the given association.

```{.json caption="Using the sort queries association feature to order results by their authors rating."}
{
  "by": {
    "association": "author",
    "attribute": "rating"
  },
  "direction": "asc"
}
```

Sorting can also be done by the sum of an associations attribute. This is done by passing an object with the key of `sum` as the `by` value. This sum object contains the association attribute name and the name of an attribute on the supplied association. This then behaves similarly to sorting by an association attribute, however, in this instance the association must be a has many association. An optional `filter` property can be supplied to specify what records of the association should be summed.

### Pagination

Finally pagination is applied - the simplest of all the steps. Like the other steps the pagination part of the request is type checked to be an object with the keys of `perPage`, `page`, and an optional key of `withCount`. `page` and `perPage` are numbers and the `withCount` a boolean.

The query limit is then set to be the value of `perPage`, and an offset is calculated from `page` and `perPage` and applied. If the `withCount` option is excluded of set to true then a flag is set on the query to include the count in the final result. This flag is discussed in more depth in the following chapter on SQL Generation.

$$ offset = (page - 1) * perPage $$

### SQL Generation

After processing is complete the query object must be transformed into SQL. The SQL is simply built up of a combination of the various elements supplied to the query by the previous step. This process is relatively simple as the previous steps provided trusted SQL into the query. This means no type checking nor sanitization needs to be performed.

```{.SQL caption="Example logic within the SqlQuery to create the final SQL"}
SELECT {columns specified joined by ","}
FROM {table name}
WHERE {conditions specified joined by " AND "}
ORDER {orders joined by ", "}
LIMIT {limit}
OFFSET {offset}
```

This SQL string will return all the correct data, however, it would not be in the proper format. So before we execute the query we generate a new select query for which the from value is equal to the previously generated sql. This query then selects a json aggregation of all the results. This means the final result will be a single json object that can be returned directly.

```{.SQL caption="Wrapping the SQL in another query to format the results"}
SELECT json_agg("results")
FROM ({the generated SQL}) "results"
```

#### The withCount flag

If the `withCount` flag is specified then a slightly different process is conducted for aggregating the results. In this instance we wrap the generated sql in the same aggregation query, but treat this as the input to the `skeem-format_results_as_object_with_count` function (described in section \ref{database_functions}).

Then we generate a completely new query following from the supplied data, this time only processing the `from` and the `where` clauses, the select, order, limit, and offset are ignored. The select of the query is set to `count(*)`. This query will return the total number of records and forms the second argument of our final function.

```{.SQL caption="Generated query if the withCount flag is present."}
SELECT "skeem-format_results_as_object_with_count"(
  {the generated SQL},
  {the generated counting SQL}
) as "results"
```
